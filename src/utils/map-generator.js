const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');

class MapGenerator {
    constructor() {
        // Color palette for different zipcode pairs in comparison mode
        this.comparisonColors = [
            { color: 'ff6600', name: 'orange' },    // Orange
            { color: '9900ff', name: 'purple' },    // Purple
            { color: '00ffff', name: 'yellow' },    // Yellow
            { color: 'ff0099', name: 'pink' },      // Pink
            { color: '00ff99', name: 'lime' },      // Lime
            { color: '99ff00', name: 'cyan' },      // Cyan
            { color: '6600ff', name: 'violet' },    // Violet
            { color: 'ff9900', name: 'gold' },      // Gold
        ];
    }

    /**
     * Calculate the center point of an array of coordinates
     * @param {Array} coordinates - Array of {latitude, longitude} objects
     * @returns {Object} Center point {latitude, longitude}
     */
    calculateMapCenter(coordinates) {
        if (!Array.isArray(coordinates) || coordinates.length === 0) {
            return null;
        }

        const validCoords = coordinates.filter(coord =>
            coord && typeof coord.latitude === 'number' && typeof coord.longitude === 'number'
        );

        if (validCoords.length === 0) {
            return null;
        }

        const sum = validCoords.reduce((acc, coord) => ({
            latitude: acc.latitude + coord.latitude,
            longitude: acc.longitude + coord.longitude
        }), { latitude: 0, longitude: 0 });

        return {
            latitude: sum.latitude / validCoords.length,
            longitude: sum.longitude / validCoords.length
        };
    }

    /**
     * Generate KML file for Google Earth with intelligent color coding
     * @param {Array} results - Array of zipcode results with coordinates
     * @param {Object} options - Options for KML generation
     * @returns {Promise<string>} Path to generated KML file
     */
    async generateKmlFile(results, options = {}) {
        const {
            centerPoint = null,
            compareResults = null,
            source = 'primary',
            compareSource = 'compare',
            filename = null
        } = options;

        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const kmlFilename = filename || `zipcode-map-${timestamp}.kml`;
            const outputPath = path.join(process.cwd(), kmlFilename);

            const kmlContent = this.buildKmlContent(results, {
                centerPoint,
                compareResults,
                source,
                compareSource
            });

            await fs.writeFile(outputPath, kmlContent, 'utf8');

            console.log(chalk.green(`ðŸ“ KML file generated: ${outputPath}`));
            return outputPath;

        } catch (error) {
            console.error(chalk.red(`âŒ Failed to generate KML file: ${error.message}`));
            return null;
        }
    }

    /**
     * Build KML content with intelligent color coding for comparison mode
     * @param {Array} results - Array of zipcode results with coordinates
     * @param {Object} options - Options for KML content
     * @returns {string} KML content
     */
    buildKmlContent(results, options = {}) {
        const {
            centerPoint = null,
            compareResults = null,
            source = 'primary',
            compareSource = 'compare'
        } = options;

        // Check if this is comparison mode
        const isComparisonMode = compareResults && Array.isArray(compareResults) && compareResults.length > 0;

        let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">
<Document>
	<name>Zipcode Lookup Results${isComparisonMode ? ' - Comparison Mode' : ''}</name>
	<open>1</open>
	<description>Generated by zipcode-lookup CLI tool</description>
	<atom:link rel="app" href="https://www.google.com/earth/about/versions/#earth-pro" title="Google Earth Pro 7.3.6.10201"></atom:link>
`;

        if (isComparisonMode) {
            // Generate styles and process comparison mode
            kml += this.generateComparisonStyles();
            kml += this.generateComparisonPlacemarks(results, compareResults, centerPoint, source, compareSource);
        } else {
            // Generate styles for single source mode
            kml += this.generateSingleSourceStyles();
            kml += this.generateSingleSourcePlacemarks(results, centerPoint, source);
        }

        kml += `
</Document>
</kml>`;

        return kml;
    }

    /**
     * Generate styles for comparison mode
     * @returns {string} KML styles
     */
    generateComparisonStyles() {
        let styles = '';

        // Generate StyleMaps and Styles for different color pairs
        this.comparisonColors.forEach((colorInfo, index) => {
            // Convert RGB to KML AABBGGRR format
            const rgb = colorInfo.color;
            const red = rgb.substring(0, 2);
            const green = rgb.substring(2, 4);
            const blue = rgb.substring(4, 6);
            const kmlColor = `ff${blue}${green}${red}`; // KML format: AABBGGRR

            styles += `
	<StyleMap id="color${index}Style">
		<Pair>
			<key>normal</key>
			<styleUrl>#color${index}Style1</styleUrl>
		</Pair>
		<Pair>
			<key>highlight</key>
			<styleUrl>#color${index}Style0</styleUrl>
		</Pair>
	</StyleMap>
	<Style id="color${index}Style0">
		<IconStyle>
			<color>${kmlColor}</color>
			<Icon>
				<href>http://maps.google.com/mapfiles/kml/pushpin/wht-pushpin.png</href>
			</Icon>
		</IconStyle>
	</Style>
	<Style id="color${index}Style1">
		<IconStyle>
			<color>${kmlColor}</color>
			<Icon>
				<href>http://maps.google.com/mapfiles/kml/pushpin/wht-pushpin.png</href>
			</Icon>
		</IconStyle>
	</Style>`;
        });

        return styles;
    }

    /**
     * Generate styles for single source mode
     * @returns {string} KML styles
     */
    generateSingleSourceStyles() {
        return `
    <!-- Center point style -->
    <Style id="centerStyle">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.3</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/grn-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>

    <!-- Primary results style -->
    <Style id="primaryStyle">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>
`;
    }

    /**
     * Generate placemarks for comparison mode with intelligent color coding
     * @param {Array} primaryResults - Primary source results
     * @param {Array} compareResults - Compare source results
     * @param {Object} centerPoint - Center point coordinates
     * @param {string} source - Primary source name
     * @param {string} compareSource - Compare source name
     * @returns {string} KML placemarks
     */
    generateComparisonPlacemarks(primaryResults, compareResults, centerPoint, source, compareSource) {
        let kml = '';

        // Create maps for easy lookup
        const primaryMap = new Map();
        const compareMap = new Map();

        if (Array.isArray(primaryResults)) {
            primaryResults.forEach(result => {
                if (this.isValidCoordinate(result.latitude, result.longitude)) {
                    primaryMap.set(result.zipcode, result);
                }
            });
        }

        if (Array.isArray(compareResults)) {
            compareResults.forEach(result => {
                if (this.isValidCoordinate(result.latitude, result.longitude)) {
                    compareMap.set(result.zipcode, result);
                }
            });
        }

        // Get all unique zipcodes
        const allZipcodes = new Set([...primaryMap.keys(), ...compareMap.keys()]);

        // Separate zipcodes into categories
        const centerZipcode = centerPoint?.zipcode;
        const zipcodeOnlyInPrimary = [];
        const zipcodesInBoth = [];

        let colorIndex = 0;

        for (const zipcode of allZipcodes) {
            const primaryResult = primaryMap.get(zipcode);
            const compareResult = compareMap.get(zipcode);

            if (zipcode === centerZipcode) {
                // Handle center zipcode separately
                continue;
            } else if (primaryResult && compareResult) {
                // Zipcode exists in both sources
                zipcodesInBoth.push({ zipcode, colorIndex: colorIndex++ });
            } else if (primaryResult && !compareResult) {
                // Only in primary source
                zipcodeOnlyInPrimary.push(zipcode);
            }
        }

        // 1. Center Point folder
        if (centerPoint && centerZipcode) {
            const primaryResult = primaryMap.get(centerZipcode);
            const compareResult = compareMap.get(centerZipcode);
            const colorInfo = this.comparisonColors[0];

            kml += `
	<Folder>
		<name>Center Point - ${centerZipcode}</name>
		<description>Zipcodes with different coordinates between sources</description>`;

            if (primaryResult) {
                kml += `
		<Placemark>
			<name>${centerZipcode} (${source})</name>
			<description>Source: ${source}
          City: ${primaryResult.city || 'N/A'}
          State: ${primaryResult.state || 'N/A'}</description>
			<styleUrl>#color0Style</styleUrl>
			<Point>
				<coordinates>${primaryResult.longitude},${primaryResult.latitude},0</coordinates>
			</Point>
		</Placemark>`;
            }

            if (compareResult) {
                kml += `
		<Placemark>
			<name>${centerZipcode} (${compareSource})</name>
			<description>Source: ${compareSource}
          City: ${compareResult.city || 'N/A'}
          State: ${compareResult.state || 'N/A'}</description>
			<styleUrl>#color0Style</styleUrl>
			<Point>
				<coordinates>${compareResult.longitude},${compareResult.latitude},0</coordinates>
			</Point>
		</Placemark>`;
            }

            kml += `
	</Folder>`;
        }

        // 2. Zipcodes Only folder
        if (zipcodeOnlyInPrimary.length > 0) {
            kml += `
	<Folder>
		<name>Zipcodes Only</name>
		<description>Zipcodes with different coordinates between sources</description>`;

            zipcodeOnlyInPrimary.forEach(zipcode => {
                const primaryResult = primaryMap.get(zipcode);
                kml += `
		<Placemark>
			<name>${zipcode} (${source})</name>
			<description>Source: ${source}
          City: ${primaryResult.city || 'N/A'}
          State: ${primaryResult.state || 'N/A'}
          Distance: ${primaryResult.distance_miles} miles</description>
			<styleUrl>#color1Style</styleUrl>
			<Point>
				<coordinates>${primaryResult.longitude},${primaryResult.latitude},0</coordinates>
			</Point>
		</Placemark>`;
            });

            kml += `
	</Folder>`;
        }

        // 3. Individual folders for zipcodes in both sources
        zipcodesInBoth.forEach(({ zipcode, colorIndex }) => {
            const primaryResult = primaryMap.get(zipcode);
            const compareResult = compareMap.get(zipcode);
            const colorInfo = this.comparisonColors[colorIndex % this.comparisonColors.length];
            const distanceDiff = primaryResult.distance_miles - compareResult.distance_miles;

            kml += `
	<Folder>
		<name>${zipcode} - ${colorInfo.name.toUpperCase()} (${distanceDiff.toFixed(2)} miles)</name>
		<description>Zipcodes with different coordinates between sources</description>`;

            if (primaryResult) {
                kml += `
		<Placemark>
			<name>${zipcode} (${source})</name>
			<description>Source: ${source}
          City: ${primaryResult.city || 'N/A'}
          State: ${primaryResult.state || 'N/A'}
          Distance: ${primaryResult.distance_miles} miles</description>
			<styleUrl>#color${(colorIndex + 2) % this.comparisonColors.length}Style</styleUrl>
			<Point>
				<coordinates>${primaryResult.longitude},${primaryResult.latitude},0</coordinates>
			</Point>
		</Placemark>`;
            }

            if (compareResult) {
                kml += `
		<Placemark>
			<name>${zipcode} (${compareSource})</name>
			<description>Source: ${compareSource}
          City: ${compareResult.city || 'N/A'}
          State: ${compareResult.state || 'N/A'}
          Distance: ${compareResult.distance_miles} miles</description>
			<styleUrl>#color${(colorIndex + 2) % this.comparisonColors.length}Style</styleUrl>
			<Point>
				<coordinates>${compareResult.longitude},${compareResult.latitude},0</coordinates>
			</Point>
		</Placemark>`;
            }

            kml += `
	</Folder>`;
        });

        return kml;
    }

    /**
     * Generate placemarks for single source mode
     * @param {Array} results - Results array
     * @param {Object} centerPoint - Center point coordinates
     * @param {string} source - Source name
     * @returns {string} KML placemarks
     */
    generateSingleSourcePlacemarks(results, centerPoint, source) {
        let kml = '';

        // Add center point if provided
        if (centerPoint) {
            kml += `
    <Placemark>
      <name>Center: ${centerPoint.zipcode || 'CENTER'}</name>
      <description>Center point for radius search</description>
      <styleUrl>#centerStyle</styleUrl>
      <Point>
        <coordinates>${centerPoint.longitude},${centerPoint.latitude},0</coordinates>
      </Point>
    </Placemark>`;
        }

        // Add results folder
        if (results && Array.isArray(results) && results.length > 0) {
            kml += `
    <Folder>
      <name>Results (${source}) - ${results.length} zipcodes</name>
      <description>Results from ${source} data source</description>`;

            results.forEach(result => {
                if (this.isValidCoordinate(result.latitude, result.longitude)) {
                    kml += `
      <Placemark>
        <name>${result.zipcode}</name>
        <description>
          City: ${result.city || 'N/A'}
          State: ${result.state || 'N/A'}
          Source: ${source}
          ${result.distance_miles ? `Distance: ${result.distance_miles} miles` : ''}
        </description>
        <styleUrl>#primaryStyle</styleUrl>
        <Point>
          <coordinates>${result.longitude},${result.latitude},0</coordinates>
        </Point>
      </Placemark>`;
                }
            });

            kml += `
    </Folder>`;
        }

        return kml;
    }

    /**
     * Analyze coordinate differences and assign colors for comparison mode
     * @param {Map} primaryMap - Map of primary results by zipcode
     * @param {Map} compareMap - Map of compare results by zipcode
     * @param {Set} allZipcodes - Set of all unique zipcodes
     * @returns {Object} Color assignments
     */
    analyzeCoordinateDifferences(primaryMap, compareMap, allZipcodes) {
        const identical = [];
        const different = [];

        let colorIndex = 0;

        for (const zipcode of allZipcodes) {
            const primaryResult = primaryMap.get(zipcode);
            const compareResult = compareMap.get(zipcode);

            // Check if both sources have this zipcode
            if (primaryResult && compareResult) {
                // Calculate coordinate difference
                const coordDiff = this.calculateCoordinateDifference(
                    primaryResult.latitude, primaryResult.longitude,
                    compareResult.latitude, compareResult.longitude
                );

                // Consider coordinates identical if difference is less than 0.001 degrees (~100 meters)
                if (coordDiff < 0.001) {
                    identical.push(zipcode);
                } else {
                    // Each zipcode with different coordinates gets its own color
                    different.push([zipcode]);
                    colorIndex++;
                }
            } else {
                // Only in one source - each gets its own color
                different.push([zipcode]);
                colorIndex++;
            }
        }

        return { identical, different };
    }

    /**
     * Calculate coordinate difference between two points
     * @param {number} lat1 - First latitude
     * @param {number} lon1 - First longitude
     * @param {number} lat2 - Second latitude
     * @param {number} lon2 - Second longitude
     * @returns {number} Coordinate difference in degrees
     */
    calculateCoordinateDifference(lat1, lon1, lat2, lon2) {
        const latDiff = Math.abs(lat1 - lat2);
        const lonDiff = Math.abs(lon1 - lon2);
        return Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);
    }

    /**
     * Validate latitude and longitude coordinates
     * @param {number} lat - Latitude
     * @param {number} lng - Longitude
     * @returns {boolean} True if valid coordinates
     */
    isValidCoordinate(lat, lng) {
        return typeof lat === 'number' && typeof lng === 'number' &&
               lat >= -90 && lat <= 90 &&
               lng >= -180 && lng <= 180 &&
               !isNaN(lat) && !isNaN(lng);
    }
}

module.exports = MapGenerator;
